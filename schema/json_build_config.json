{
  "includes": ["src/proto"],
  "files": ["src/proto/structs.proto", "src/proto/execution.proto"],
  "output": "build",
  "opts": [
    {
      "scope": "type",
      "description": "serde support for message",
      "attr": "#[serde_with::serde_as]\n#[derive(serde::Serialize, serde::Deserialize, Eq, std::hash::Hash)]",
      "paths": [
        "structs.Transaction", "structs.Proof",
        "structs.PoWProof", "structs.ProductId",
        "structs.Input", "structs.Output",
        "structs.ObservationMetadata", "structs.Observation",
        "structs.MerkleNode", "structs.MerkleProof", "structs.MerkleProofElement",
        "structs.ResponseMetadata", "structs.ErrorInfo", "structs.ErrorDetails",
        "structs.Request", "structs.Response",
        "structs.ControlRequest", "structs.ControlResponse",
        "structs.PublicRequest", "structs.PublicResponse",
        "structs.SubmitTransactionRequest", "structs.SubmitTransactionResponse",
        "structs.GossipTransactionRequest", "structs.GossipTransactionResponse",
        "structs.GossipObservationRequest", "structs.GossipObservationResponse",
        "structs.QueryTransactionRequest", "structs.QueryTransactionResponse",
        "structs.ResolveHashRequest", "structs.ResolveHashResponse",
        "structs.AboutNodeRequest", "structs.AboutNodeResponse",
        "structs.DownloadRequest", "structs.DownloadResponse",
        "structs.ObservationProof",
        "structs.OutputContract",
        "structs.TypedValue",
        "structs.TimeLockWindow",
        "structs.KeyValueOption",
        "structs.TransactionContract",
        "structs.TransactionData",
        "structs.CodeExecutionContract",
        "structs.UtxoEntry",
        "structs.ObservationEdge",
        "structs.BytesData",
        "structs.TransactionOptions",
        "structs.Tombstone",
        "structs.TrustLabel",
        "structs.NodeMetadata",
        "structs.PeerData",
        "structs.StandardData",
        "structs.KeyedTypedValue",
        "structs.TransactionEntry",
        "structs.ObservationEntry",
        "structs.QueryAddressesRequest",
        "structs.QueryAddressesResponse",
        "structs.Address",
        "structs.PartitionInfo",
        "structs.Signature",
        "structs.PublicKey",
        "structs.MatrixTypedValue",
        "structs.Hash",
        "structs.Block",
        "structs.BlockMetadata",
        "structs.StructMetadata",
        "structs.AddressBlock",
        "structs.FaucetRequest",
        "structs.FaucetResponse",
        "structs.RecentTransactionsRequest",
        "structs.RecentTransactionsResponse",
        "structs.HashSearchRequest",
        "structs.HashSearchResponse",
        "structs.TransactionInfo",
        "structs.TransactionAmount",
        "structs.AddressInfo",
        "structs.GetPeersInfoResponse",
        "structs.GetPeersInfoRequest",
        "structs.MultipartyThresholdRequest",
        "structs.MultipartyThresholdResponse",
        "structs.MultipartyBroadcast",
        "structs.MultipartyIssueUniqueIndex",
        "structs.MultipartySubscribe",
        "structs.MultipartySubscribeEvent",
        "structs.MultipartyIssueUniqueIndexResponse",
        "structs.TrustData",
        "structs.PeerId",
        "structs.InitiateMultipartyKeygenRequest",
        "structs.InitiateMultipartySigningRequest",
        "structs.MultipartyIdentifier",
        "structs.InitiateMultipartyKeygenResponse",
        "structs.InitiateMultipartySigningResponse",
        "structs.UdpMessage",
        "structs.DynamicNodeMetadata",
        "structs.Seed",
        "structs.FloatingUtxoId",
        "structs.FixedUtxoId",
        "structs.UsedOutputs",
        "structs.OfflineTimeSponsor",
        "structs.UtxoConflictResolveRequest",
        "structs.UtxoConflictResolveResponse",
        "structs.PeerNodeInfo",
        "structs.QueryObservationProofResponse",
        "structs.QueryObservationProofRequest",
        "structs.TaskLocalDetails",
        "structs.DebugVersionChange",
        "structs.DebugVersionChange2",
        "structs.PeerIdInfo",
        "structs.ControlMultipartySigningRequest",
        "structs.ControlMultipartyKeygenRequest",
        "structs.ControlMultipartySigningResponse",
        "structs.ControlMultipartyKeygenResponse",
        "structs.MultipartyAuthenticationRequest",
        "structs.HealthRequest",
        "structs.HealthResponse",
        "structs.GetNodeTransactionRequest",
        "structs.AddressSelector",
        "structs.ExecutionInput",
        "structs.ExecutionResult",
        "structs.TestContractRequest",
        "structs.TestContractUpdate",
        "structs.TestContractUpdate2",
        "structs.TestContractInternalState",
        "structs.ContractStateMarker",
        "structs.StateSelector",
        "structs.GetContractStateMarkerRequest",
        "structs.VersionInfo"
      ]
    },
    {
      "scope": "type",
      "description": "serde support for enum",
      "attr": "#[derive(serde::Serialize, serde::Deserialize, strum_macros::EnumString)]",
      "paths": [
        "structs.TransactionState",
        "structs.ValidationType",
        "structs.State",
        "structs.HashType",
        "structs.Error",
        "structs.StandardContractType",
        "structs.DownloadDataType",
        "structs.NetworkEnvironment",
        "structs.BytesDecoder",
        "structs.NodeType",
        "structs.SignatureType",
        "structs.PublicKeyType",
        "structs.HashFormatType",
        "structs.ExecutorBackend",
        "structs.OutputType",
        "structs.AddressType"
      ]
    },
    {
      "scope": "field",
      "description": "hex bytes",
      "attr": "#[serde_as(as = \"serde_with::hex::Hex\")]",
      "paths": [
        "structs.PoWProof.proof",
        "structs.AddPeerFull.id",
        "structs.AddPeerFull.public_key",
        "structs.BytesData.value",
        "structs.Tombstone.hash",
        "structs.NodeMetadata.multi_hash",
        "structs.AddressBlock.hash",
        "structs.AddressBlock.address",
        "structs.TrustLabel.peer_id"
      ]
    },
    {
      "scope": "field",
      "description": "base64 bytes",
      "attr": "#[serde(serialize_with = \"crate::process_transaction::as_base64\", deserialize_with = \"crate::process_transaction::from_base64\")]",
      "paths": []
    },
    {
      "scope": "field",
      "description": "skip string default values",
      "attr": "#[serde(skip_serializing_if = \"String::is_empty\", default)]",
      "paths": []
    },
    {
      "scope": "field",
      "description": "skip option default values",
      "attr": "#[serde(skip_serializing_if = \"Option::is_none\", default, deserialize_with = \"prost_helper::deserialize_null_default\")]",
      "paths": [
        "structs.StandardData.typed_value",
        "structs.StandardData.matrix_typed_value",
        "structs.StandardData.peer_data",
        "structs.StandardData.node_metadata",
        "structs.StandardData.dynamic_node_metadata",
        "structs.StandardData.height",
        "structs.StandardData.data_hash",
        "structs.StandardData.hash",
        "structs.Output.contract",
        "structs.Output.product_id",
        "structs.Transaction.options",
        "structs.StructMetadata.signable_hash",
        "structs.StructMetadata.signed_hash",
        "structs.StructMetadata.counter_party_hash",
        "structs.StructMetadata.confirmation_hash",
        "structs.ResponseMetadata.error_info",
        "structs.ResponseMetadata.request_id",
        "structs.ResponseMetadata.trace_id",
        "structs.Request.gossip_transaction_request",
        "structs.Request.gossip_observation_request",
        "structs.Request.resolve_hash_request",
        "structs.Request.download_request",
        "structs.Request.get_peers_info_request",
        "structs.Request.multiparty_threshold_request",
        "structs.Request.submit_transaction_request",
        "structs.Request.hash_search_request",
        "structs.Request.trace_id",
        "structs.Request.trace",
        "structs.Request.utxo_conflict_resolve_request",
        "structs.Request.query_observation_proof_request",
        "structs.Request.about_node_request",
        "structs.Request.get_peers_info_request",
        "structs.Response.utxo_conflict_resolve_response",
        "structs.Response.multiparty_threshold_response",
        "structs.Response.query_observation_proof_response",
        "structs.Response.resolve_hash_response",
        "structs.Response.download_response",
        "structs.Response.about_node_response",
        "structs.Response.get_peers_info_response",
        "structs.Response.hash_search_response",
        "structs.Response.submit_transaction_response",
        "structs.NodeMetadata.proof",
        "structs.NodeMetadata.partition_info",
        "structs.NodeMetadata.alias",
        "structs.NodeMetadata.name",
        "structs.NodeMetadata.nat_restricted",
        "structs.VersionInfo.commit_hash",
        "structs.VersionInfo.next_executable_checksum",
        "structs.VersionInfo.next_upgrade_time",
        "structs.StandardData.keyed_typed_value"
      ]
    },
    {
      "scope": "field",
      "description": "skip vec default values",
      "attr": "#[serde(skip_serializing_if = \"Vec::is_empty\", default, deserialize_with = \"prost_helper::deserialize_null_default\")]",
      "paths": [
        "structs.StandardData.typed_value_list",
        "structs.Transaction.inputs",
        "structs.Output.counter_party_proofs",
        "structs.StandardData.keyed_typed_value_list",
        "structs.StandardData.matrix_typed_value_list",
        "structs.ResponseMetadata.task_local_details"
      ]
    },
    {
      "scope": "field",
      "description": "skip null values",
      "attr": "#[serde(deserialize_with = \"prost_helper::deserialize_null_default\")]",
      "paths": [
      ]
    },
    {
      "scope": "field",
      "description": "skip null values",
      "attr": "#[serde(deserialize_with = \"prost_helper::deserialize_null_default\")]",
      "paths": [
      ]
    },
    {
      "scope": "field",
      "description": "skip 0 for any num",
      "attr": "#[serde(skip_serializing_if = \"num_traits::identities::Zero::is_zero\", default)]",
      "paths": [
        "structs.Hash.hash_type",
        "structs.BytesData.decoder",
        "structs.BytesData.version",
        "structs.StructMetadata.version",
        "structs.Hash.hash_format_type",
        "structs.Address.address_type"
      ]
    },
    {
      "scope": "field",
      "description": "skip the field for serialization",
      "attr": "#[serde(skip_serializing)]",
      "paths": []
    },
    {
      "scope": "bytes",
      "description": "use bytes::Bytes for given bytes field",
      "paths": []
    },
    {
      "scope": "btree_map",
      "description": "use BtreeMap for given map field",
      "paths": []
    }
  ]
}