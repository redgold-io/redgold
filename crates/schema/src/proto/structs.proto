syntax = "proto3";

package structs;

// The verification type associated with a signature. Denotes common patterns, i.e. the default common ECDSA curve
// and parameters, or a custom curve denoted by a particular enum, or a particular signing algorithm.
// Each specific curve type or signing algorithm should be assigned it's own enum here, so that the signing
// flow can be recreated from a single reference.
enum SignatureType {
  // The most common secp256k1 curve used for Bitcoin and Ethereum, corresponds to the standard ECDSA signature
  // used by most hardware / software wallets
  ECDSA = 0;
  // The same curve as above, but following the Bitcoin Message signing strategy in order to make use of existing
  // hardware cold wallets, can be deprecated once hardware wallet support is added for native signatures matching
  // Redgold schema.
  EcdsaBitcoinSignMessageHardware = 1;
  // The raw RSV signature outputs, used for ETH compatibility.
  ECDSARecoverable = 2;
}

message RsvSignature {
  BytesData r = 1;
  BytesData s = 2;
  optional int64 v = 3;
}

// The raw data associated with a signature, along with type information for how to verify it. Does not include
// the public key associated with the signature, which is stored separately (unless the signature type contains
// recovery id within the bytes.)
message Signature {
  BytesData bytes = 1;
  SignatureType signature_type = 2;
  RsvSignature rsv = 3;
}

// Future placeholder in the event of use of different public key types, will eventually cover ed25519 etc.
enum PublicKeyType {
  // ECDSA Standard key type matching ECDSA signature type above
  secp256k1 = 0;
  ed25519 = 1;
}

// Compressed public key byte data (33 bytes for standard ECDSA)
message PublicKey {
  // Encoded data form of the public key, requires a library for decoding to appropriate key instance
  BytesData bytes = 1;
  // The type of public key, used to determine how to decode the bytes into a key instance
  // For instance, ecdsa variant or ed25519
  PublicKeyType key_type = 2;
  // Used for Monero ed25519 which requires a secondary public key to derive an address, kept here
  // for consistency with other PK -> Address derivation patterns.
  BytesData aux_data = 3;
}



// Witness data for a particular signing event, does not include the hash required to re-verify the information.
message Proof {
  // Raw signing data, associated with the signature of a particular, individual hash, typically a transaction hash
  Signature signature = 1;
  // The public key of the key that produced this signature, required to verify the signature in the event the
  // signature type does not implement a recovery id.
  PublicKey public_key = 2;
}

enum PoWProofType {
  // The standard sha3-256 hash of the transaction
  Sha3_256_Nonce = 0;
}

// Currently unused, but an optional anti-spam proof included in a transaction for increased mem-pool priority
message PoWProof {
  PoWProofType proof_type = 1;
  BytesData index_counter = 2;
}

// Equivalent to a chainId identifier. Used as a marker for contracts or simplicity to indicate information
// associated with the origin of a particular amount. Useful for schema-represented ERC-20 equivalent products.
// Or other schema-driven contract definitions.
message ProductId {
  CurrencyId currency_id = 1;
}


// TODO: Support other output extraction operations, a function that processes a transaction and results ?

// Standard UTXO identifier similar to Bitcoin schema.
message UtxoId {
  // The hash associated with a parent / ancestor transaction which has already been accepted as valid.
  Hash transaction_hash = 1;
  // The index of the output in the parent transaction which is being spent / consumed.
  int64 output_index = 2;
}

message AddressSelector {
  Address address = 1;
  // Some type of query predicate here -- or a bool such that the input's output marks this contract address
  optional bool requires_output_contract_predicate_match = 2;
}

message FloatingUtxoId {
  AddressSelector address_selector = 1;
  // TODO: Contract execution here.
}

message OutputIndex {
  int64 output_index = 1;
}

enum InputType {
  GenesisInput = 0;
}

message Input {

  UtxoId utxo_id = 1;
  // The signed proof that this input is a valid reference to the previous output.
  repeated Proof proof = 3;
  // The identifier associated with the currency or product being used, for multi-currency support.
  ProductId product_id = 4;
  FloatingUtxoId floating_utxo_id = 6;
  optional InputType input_type = 7;

  // Enriched / calculated field from proof -- not necessary to store, must recalculate this always;
  Address address = 8;
  // Hydration purposes only! Not used for hashes, this represents the previous output.
  Output output = 5;

}

enum RatingType {
  // Conventional rating associated with likelihood to commit double spend or malicious node behavior
  SecurityRating = 0;
  // Rating associated with multi-party computation, should always be strictly speaking more
  // risky than normal security
  DepositRating = 1;
}

message TrustData {
  // A score from -1 to 1 normalized to 1e3 (1000) scale for Equality avoidance of floats
  // Otherwise equivalent to a rounded float
  Weighting label_rating = 2;
  // Confidence level associated with the label, how certain is this value?
  Weighting confidence = 3;
  // Variance associated with the confidence estimate, sigma / stddev
  Weighting hardness = 5;
  // Additional unstructured or otherwise custom label data
  StandardData data = 6;
  optional bool allow_model_override = 7;
  RatingType rating_type = 8;
}

message TrustRatingLabel {
  PeerId peer_id = 1;
  repeated TrustData trust_data = 2;
}

message PartitionInfo {
  optional int64 utxo = 1;
  optional int64 contract_address = 2;
  optional int64 transaction_hash = 3;
  optional int64 address = 4;
}

// How to contact the node
message TransportInfo {
  // Exact IPv4 address
  optional string external_ipv4 = 14;
  // Exact IPv6 address
  optional string external_ipv6 = 15;
  // CNAME like reference i.e. node.example.com
  optional string external_host = 16;
  // Base port reference for the node, i.e. 16180 -- offsets are used for each API
  // Defaults to network standard ports
  optional int64 port_offset = 8;
  optional bool nat_restricted = 12;
}

message PartyId {
  // The t-ECDSA generated key used to derive Bitcoin, Ethereum, Redgold, etc. addresses.
  PublicKey public_key = 1;
  // Public key associated with the party initiator
  PublicKey owner = 2;
}

// Per node (machine) metadata, intended to be updated automatically by the hot key on the machine
message NodeMetadata {
  // Information about how to contact the node
  TransportInfo transport_info = 1;
  // Public key associated with the node signatures for real-time signatures, such as observations
  PublicKey public_key = 2;
  // What type of node this is, in terms of whether it stays online consistently or is ephemeral
  // and can't be relied upon to be continuously online.
  optional NodeType node_type = 5;
  // Information about the executable and other checksums, also used for coordinating upgrades
  optional VersionInfo version_info = 6;
  // Distances to various types of hashes for partitioning and storage of data. Used for optimizing gossip
  // and long term storage.
  optional PartitionInfo partition_info = 7;
  // Identifier for the particular machine, not guaranteed to be unique across network.
  // Public key should be used primarily, this is only for convenience.
  optional string node_name = 8;
  // Corresponding public key of the overall identity controlling this, and other nodes
  PeerId peer_id = 9;
  // Parties of participation. Used for multi-party computation and other multi-party operations.
  repeated PartyId parties = 10;
}

/**
Used to store the version of the executable and the commit hash of the source code used to build it.
Security verifications associated with the node software should be done with this message.
 */
message VersionInfo {
  // The value associated with the Sha2-256 hash of the executable calculated with shasum locally
  // Should match github release page.
  string executable_checksum = 1;
  // This is only really useful in the security scenario where the node is building from source
  // Otherwise, even if filled with a value from git, it's not really verified
  optional string commit_hash = 2;
  // Same as prior hash except the intended upgrade hash of a node, not yet used.
  optional string next_executable_checksum = 3;
  // Intended time for performing a software update, for coordination of upgrades (not yet used.)
  optional int64 next_upgrade_time = 4;
  // Build number associated with GitHub actions release action counter
  // Should correspond directly to the executable hash, check the releases page for the correspondence
  optional int64 build_number = 5;
}

message PeerId {
  PublicKey peer_id = 1;
}

// All of this is optional, used for external verifications
message IdentityMetadata {
  optional string github_username = 1;
  optional string website = 2;
  optional string full_name = 9;
  optional string username = 10;
  optional string email = 11;
  optional string discord_id = 12;
  optional string twitter = 13;
}

message Weighting {
  int64 value = 1;
  optional int64 basis = 2;
}

message PortfolioWeighting {
  optional SupportedCurrency currency = 1;
  ProductId product_id = 2;
  Weighting weight = 3;
}

message PortfolioInfo {
  repeated PortfolioWeighting portfolio_weightings = 1;
}

message PeerMetadata {
  optional PeerId peer_id = 1;
  repeated NodeMetadata node_metadata = 4;
  repeated TrustRatingLabel labels = 5;
  optional VersionInfo version_info = 6;
  Address reward_address = 7;
  repeated Address sponsored_address = 8;
  IdentityMetadata identity_metadata = 12;
  NetworkEnvironment network_environment = 13;
  PortfolioInfo portfolio_info = 14;
}

enum BytesDecoder {
  STANDARD = 0;
}

message BytesData {
  bytes value = 1;
  BytesDecoder decoder = 2;
  int32 version = 3;
}

enum HashFormatType {
  Sha3_256 = 0;
  Unknown_Format = 1;
  Keccak_256 = 2;
}

message Hash {
  BytesData bytes = 1;
  HashFormatType hash_format_type = 2;
  HashType hash_type = 3;
}

message DynamicNodeMetadata {
  optional int64 udp_port = 1;
  Proof proof = 2;
  PeerId peer_id = 3;
  int64 sequence = 4;
}

message AbridgedNodeMetadata {
  VersionInfo version_info = 1;
  PartitionInfo partition_info = 2;
}

message PortfolioId {
  optional string name = 1;
}

message PortfolioRequest {
  PortfolioInfo portfolio_info = 1;
  PortfolioId portfolio_id = 2;
}


message StandardRequest {
  StateSelector selector = 1;
  // Staking request, designed for use with the native AMM/Portfolio functions.
  StakeRequest stake_request = 2;
  // Portfolio information, used for updating the current 'target' state of a portfolio
  PortfolioRequest portfolio_request = 3;
  // Used for collateralized loan outputs
  CollateralizedLoanRequest collateralized_loan = 4;
  // Used for swaps
  SwapRequest swap_request = 5;
  // Used for arbitrary deposits which have no specific use yet.
  DepositRequest deposit_request = 6;
}

message SchemaDef {
  optional string parquet = 1;
}

message GenericTypedValue {
  optional TypedValue typed_value = 2;
  repeated TypedValue typed_value_list = 3;
  optional KeyedTypedValue keyed_typed_value = 4;
  repeated KeyedTypedValue keyed_typed_value_list = 5;
  optional MatrixTypedValue matrix_typed_value = 6;
  repeated MatrixTypedValue matrix_typed_value_list = 7;
}

message ExternalTransactionId {
  string identifier = 1;
  SupportedCurrency currency = 2;
}

message InterestRate {
  Weighting fixed_rate_apy = 1;
}

// This is essentially a request for a loan.
message CollateralizedLoanInitiation {
  Address destination_caller = 1;
  InterestRate interest_rate = 2;
}

message CollateralizedLoanFulfillment {
  UtxoId initiation = 1;
}
message CollateralizedLoanCall {

}

message CollateralizedLoanRepayment {}


message CollateralizedLoanRequest {
    CollateralizedLoanInitiation initiation = 1;
}

message SwapRequest {
  // This can be an internal or external destination.
  Address destination = 1;
  // TODO: Limit parameters here for max price to issue at
}

message SwapFulfillment {
  // A bitcoin txid for example
  ExternalTransactionId external_transaction_id = 25;
}

message DepositRequest {
  // The (external) address to watch for deposits
  Address address = 1;
  // Proof that you own this external address, if missing, defaults to first input proof
  Proof proof = 2;
  // The amount expected to be deposited
  CurrencyAmount amount = 3;
}

message StakeWithdrawalFulfillment {
  UtxoId stake_withdrawal_request = 1;
}

message StandardResponse {
  SwapFulfillment swap_fulfillment = 1;
  CollateralizedLoanFulfillment collateralized_loan_fulfillment = 2;
  StakeWithdrawalFulfillment stake_withdrawal_fulfillment = 3;
}
// Generic data structure designed to hold arbitrary data in a common format.
// This should be considered supplementary to using a regular schema, not a
// complete substitute.
message StandardData {
  // Standard currency style field
  CurrencyAmount amount = 1;
  GenericTypedValue generic_typed_value = 2;
  // Where a peer (representing a person controlling multiple nodes from a cold wallet,) updates it's metadata
  // within a transaction
  optional PeerMetadata peer_data = 8;
  // Where an online or live node programmatically updates it's own metadata using it's live hot keys
  optional NodeMetadata node_metadata = 9;
  // Latest value associated with the online / hot node -- updated more frequently and not necessarily tracked in
  // every transaction, but kept here for reference.
  optional DynamicNodeMetadata dynamic_node_metadata = 10;
  // Equivalent to 'block height', linear observation counter
  optional int64 height = 11;
  // Reference to externally resolved data
  Hash data_hash = 12;
  // Pure hash reference, without necessarily being backed by any specific data.
  Hash hash = 13;
  // Used for node transactions related to their internal observation formation, equivalent to a 'local' block
  Observation observation = 14;
  // Used for referencing bitcoin address, kept here at top level for convenience
  Address address = 15;
  // Used to store state information directly following eUTXO conventions
  BytesData state = 17;
  // Contract style request, similar to Ethereum transaction for updating a smart contract, from an external user
  BytesData request = 18;
  // Contract style response, similar to above, but specifically typed to correspond to a 'default' schema driven
  // request common to all contracts and available automatically in the SDK.
  StandardRequest standard_request = 19;
  StandardResponse standard_response = 20;
  // Schema definition for the data, used for parsing and validation
  SchemaDef schema_def = 22;
  // Generic bytes data, used for storing arbitrary data
  BytesData data = 23;
  // For eUTXO style contracts, the hash of all state information aggregated from initial state origin.
  // Can be re-calculated.
  Hash aggregate_state_hash = 24;

}

// Native staking range to provide liquidity within. Trades cannot be executed outside of this range
message LiquidityRange {
  // No trades can be executed below this amount
  CurrencyAmount min_inclusive = 1;
  // No trades can be executed above this amount
  CurrencyAmount max_exclusive = 2;
  // Whether or not to disable dynamic fee calculation, default false
  bool disable_dynamic_fee = 3;
  // Minimum fees required to be collected for this range, optional for defaults
  Weighting desired_fee_fraction = 4;
  // How much of the total input staking quantity to allocate to this range, defaults to equal division among fractions
  Weighting allocation_fraction = 5;
  optional bool ask_filter = 6;
}

// Request to withdraw liquidity from a pool
message StakeWithdrawal {
  Address destination = 1;
}

message PortfolioFulfillmentParams {

}

// Pre-claim deposit operation designating native multiparty groups to watch address for native deposits
// Requires that the address on this network match the address of the external network, so that the private
// key used for both is the same.
message StakeDeposit {
  // Each value should be a uniquely defined, non-overlapping range of liquidity to provide within for AMM-like activity
  repeated LiquidityRange liquidity_ranges = 1;
  DepositRequest deposit = 2;
  // Indicates the stake may be used to fulfill portfolio target requests.
  PortfolioFulfillmentParams portfolio_fulfillment_params = 3;
}

// Request to update external liquidity to a native pool
message StakeRequest {
  // A marker for a future external (native to the external currency,) deposit to a multiparty AMM-like pool
  StakeDeposit deposit = 1;
  // A withdrawl request, indicating to the pool to send funds to the specified external chain address
  StakeWithdrawal withdrawal = 2;
}

// Generically typed value, used for storing arbitrary data in a common format.
message KeyedTypedValue {
  // Generically typed key, for lookups
  TypedValue key = 1;
  // Generically typed value, for storage
  TypedValue value = 2;
}

// Same as KeyedTypedValue, but specific for matrix data.
message MatrixTypedValue {
  TypedValue key_i = 1;
  TypedValue key_j = 2;
  TypedValue value = 3;
}

// Generically typed value class, used for representing arbitrary data
message TypedValue {
  optional BytesData bytes_value = 2;
  optional string string_value = 3;
  optional uint64 uint64_value = 1;
  optional int64 int64_value = 5;
  // Used to avoid Eq comparison problem in rust for strings encoded from floats.
  // Can also use bytes_value, but this is easier to read.
  optional string float_value = 7;
  optional string double_value = 4;
  optional bool bool_value = 6;
}

enum StandardContractType {
  CURRENCY = 0;
  DEPOSIT = 1;
  SWAP = 2;
  STAKE = 3;
  CollateralizedLoan = 4;
}

message KeyValueOption {
  string key = 1;
  string value = 2;
}

enum ExecutorBackend {
  Extism = 0;
  Evm = 1;
}

message CodeExecutionContract {
  Address address = 1;
  BytesData code = 2;
  optional ExecutorBackend executor = 3;
}

message OutputContract {
  // hash references, same issue as other thing
  optional StandardContractType standard_contract_type = 1;
  CodeExecutionContract code_execution_contract = 2;
  Weighting threshold = 3;
  repeated Weighting weights = 4;
  // What was this for? Are we ever gonna send to an address filter predicate that is different from the output address?
//  Address filter_predicate_destination = 5;
  bool pay_update_descendents = 6;
  bool consumable = 7;
  repeated StandardContractType standard_contracts = 8;
}

enum OutputType {
  Fee = 0;
  Deploy = 1;
  RequestCall = 2;
  Loan = 3;
}

enum TransactionType {
  Standard = 0;
  ObservationType = 1;
  Stake = 2;
  Swap = 3;
}

message Output {
  // Basic unlock condition for using this as a consumable input. Script hash or hash of a public key.
  Address address = 1;
  ProductId product_id = 5;
  repeated Proof counter_party_proofs = 6;
  // change to outputData?
  StandardData data = 7;
  OutputContract contract = 8;
  optional OutputType output_type = 9;
  // Used for specifying UTXO contract reference as well as address.
  UtxoId utxo_id = 10;
}

// monthly / daily / window size + window center
message TimeLockWindow {
  uint64 delay = 1;
  uint64 offset = 2;
  uint64 window_size = 3;
}

message CurrencyAmount {
  int64 amount = 1;
  optional SupportedCurrency currency = 2;
  // Support for arbitrary amount, used for multi-currency support
  optional string string_amount = 3;
  BytesData bytes = 4;
  optional string decimals = 5;
  optional CurrencyId currency_id = 6;
  // The currency type associated with the amount, used for multi-currency support
}

message TransactionData {
  optional string message = 1;
  optional uint64 time = 2;
  optional StandardData standard_data = 3;
}

message TransactionContract {
  // input gets signed with a proof;
  // output gets signed with a counter-party proof;
  // transaction then
  // should this confirmation thing be on the output or the transaction??? Transaction
  optional bool confirmation_= 1;
  repeated Proof confirmation_proofs = 2;
  // How long the network / each node must wait between PENDING and finalization
  optional uint64 finalize_window = 3;
  // How long the network must wait after FINALIZED to use.
  optional uint64 lock_period = 4;
  // Used to allow network criteria to vote on reversing in event of hacking.
  optional bool network_reversible = 5;

  optional TimeLockWindow time_lock_window = 6;
  repeated KeyValueOption options = 7;

}

enum NetworkEnvironment {
  // Production release, using real data and currency
 MAIN = 0;
 // Pre-production release, used for integration testing with release version before updating main net
 TEST = 1;
 // Latest dev branch code, continuously updated from latest build, unstable and non-release version
 DEV = 2;
 // Latest staging branch code, continuously updated but considered stable, upon verification is rolled to test net
 STAGING = 3;
 // Performance testing network, used for debugging performance issues and not tied to a particular version or stage
  // Can be manually set as for debugging, generally paired with staging code.
 PERF = 4;
 // Manually deployed network over arbitrary machines
  INTEGRATION = 5;
 // Designation for an entire network running as local processes not connecting to external services
 LOCAL = 6;
 // Designation for an entire network running within a single process. Either with mock-ups or other testing
  // harnesses -- generally used for debugging within an IDE,
 DEBUG = 7;
 // Operations which can potentially span all networks, like a host manager or infrastructure configuration.
 ALL = 8;
  // Testing branch before dev, force push commits here for manual debugging, one user at a time.
  PREDEV = 9;
}

message Salt {
  int64 value = 1;
}

// For use in providing a secondary, recent, submission time for offline signing process with delayed broadcast.
message TimeSponsor {
  int64 time = 1;
  Proof proof = 2;
}

message TransactionOptions {
  optional int64 salt = 1;
  optional NetworkEnvironment network_type = 2;
  repeated KeyValueOption key_value_options = 3;
  TransactionData data = 4;
  TransactionContract contract = 5;
  TimeSponsor time_sponsor = 6;
  // Used for marking a test transaction for filtering from indexes
  // Primarily used by the live E2E but also appropriate for small, user initiated tests
  optional bool is_test = 7;
  // Used only for anti-spam limiting at low limits.
  PoWProof pow_proof = 8;
  TransactionType transaction_type = 9;
}

message Transaction {
  repeated Input inputs = 1;
  repeated Output outputs = 2;
  StructMetadata struct_metadata = 3;
  TransactionOptions options = 4;
}

message BlockMetadata {
}

// Information about the data type itself, such as time produced and hash representations of it
message StructMetadata {
  // If present, represents some time related information that should be signed, typically transaction origination time
  optional int64 time = 1;
  // The version of the object, used for backwards / forward compatability and to determine which fields are present
  int32 version = 2;
  // The hash of the present object data, including all relevant fields, but excluding any enriched / hydrated data fields
  // This can be any one of the below hash values, and reflects the current state of the object.
  Hash hash = 3;
  // The hash of the object data, excluding any witness information, object should be cleared of other fields
  // or hydration related fields before signing.
  // This is equivalent to the SegWit hash.
  Hash signable_hash = 5;
  // The hash of the object after being signed once, this is the hash that includes the witness data / signature data.
  // This is equivalent to the hash of a transaction containing witness data ala standard ETH transaction.
  Hash signed_hash = 6;
  // The hash of the object after being signed twice, includes witness data from a counter-signature from an
  // accepting party. Used for transaction contracts that require counter party acceptance
  Hash counter_party_hash = 7;
  // The hash of the object after being signed three times, includes witness data from original signer,
  // counter-signer accepting party, and a final signature from the original of the counter party hashed object.
  Hash confirmation_hash = 8;
}

message AddressBlock {
  Address address = 1;
  CurrencyAmount balance = 2;
  int64 height = 3;
  Hash hash = 4;
}


// Only used for building deterministic blocks for legacy compatibility
// NOT used for authoritative proof, instead rely on merkle proofs
// NOT guaranteed to be globally unique
message Block {
  Hash merkle_root = 1;
  // These are dropped for the hash calculation as the merkle root is present.
  repeated Transaction transactions = 2;
  StructMetadata struct_metadata = 3;
  Hash previous_block_hash = 4;
  BlockMetadata metadata = 5;
  // Not really needed for hash calc, but harmless to include
  int64 height = 7;
}

enum State {
  Pending = 0;
  Accepted = 1;
  Reverted = 2;
  Ordered = 3;
}

enum HashType {
  TRANSACTION = 0;
  OBSERVATION_METADATA = 1;
  OBSERVATION_MERKLE_ROOT = 2;
  TOMBSTONE = 3;
  ADDRESS = 4;
  UNKNOWN = 5;
  Utxo_Id = 6;
  Contract = 7;
}

message Tombstone {
  Hash hash = 1;
  // TODO: Other fields for the reason 'why'
}

enum ValidationType {
  // Perfect validation with all resolved dependencies
  FULL = 0;
  PARTIAL = 1;
}

enum ValidationLiveness {
  Live = 0;
  PostConfirmation = 1;
}

// Metadata associated with some node observing and validating data associated with some hash
message ObservationMetadata {
  // The data under consideration which has had some validation performed for it.
  Hash observed_hash = 1;
  // Whether or not we have fully resolved all prior dependencies associated with the data internally
  ValidationType observation_type = 2;
  // How much we have accepted this data, whether or not sufficient time has passed to consider it confirmed
  State state = 3;
  // The degree of certainty associated with our validation, based on trustworthiness of information received from
  // other peers
  TrustData validation_confidence = 4;
  // Information about this object itself, such as time produced and hash representations of it
  StructMetadata struct_metadata = 5;
  // Whether or not we consider this data already confirmed, or in process.
  ValidationLiveness validation_liveness = 6;
  // How certain we are of the liveness.
  TrustData liveness_confidence = 7;
}

message AncestorMerkleRoot {
  Hash root = 1;
  int64 divmod_height = 2;
}

// TODO: Salt? Peer identifier? Etc
message Observation {
  // Merkle root of observations
  Hash merkle_root = 1;
  // Individual metadata of observations, contains all metadata associated with the observation, but not the
  // underlying data of what was observed
  repeated ObservationMetadata observations = 2;
  // Hash of the preceding observation reference output
  UtxoId parent_id = 3;
  repeated Hash ancestor_merkle_roots = 4;
}

// Derived data structure, not a primary chain data structure
message ObservationEdge {
    ObservationProof observation_proof = 1;
    int64 time = 2;
}


// Derived data structure, not a primary chain data structure
message UtxoEntry {
  UtxoId utxo_id = 1;
  Output output = 4;
  int64 time = 5;
}

// TODO: unify types here
message EagerFullGossipPush {
  repeated Transaction transactions = 1;
  repeated Observation observations = 2;
  repeated ObservationEdge observation_edges = 3;
  repeated PeerMetadata peer_data = 7;
}

// These should both be broadcasts at some point
// Consider using a response here if needed.
message GossipTransactionRequest {
  Transaction transaction = 1;
}

// TODO: Might be best to just remove this entirely later and route it through transactions
message GossipObservationRequest {
  Transaction observation = 1;
}


message ResolveHashRequest {
  Hash hash = 1;
  optional int64 output_index = 2;
}

// Add request id's here??

message ResolveHashResponse {
  TransactionInfo transaction_info = 1;
  AddressInfo address_info = 2;
  Observation observation = 3;
  PeerMetadata peer_data = 4;
}


enum DownloadDataType {
  // May be able to remove
  UTXO_ENTRY = 0;
  TRANSACTION_ENTRY = 1;
  OBSERVATION_ENTRY = 2;
  OBSERVATION_EDGE_ENTRY = 3;

  // Currently unsupported
  BLOCK_ENTRY = 4;
  SNAPSHOT_ENTRY = 5;
  // Beginning of download process
  UTXO_HASH = 6;
  // Historical transactions / archival data
  TRANSACTION_HASH = 7;
  OBSERVATION_TX_HASH = 8;
}

message DownloadRequest {
    uint64 start_time = 1;
    uint64 end_time = 2;
    DownloadDataType data_type = 3;
    optional uint64 offset = 4;
    PartitionInfo partition_info = 5;
}

// Only used temporarily for download, not reliable 'time' value
message TransactionEntry {
  uint64 time = 1;
  Transaction transaction = 2;
}

message ObservationEntry {
  int64 time = 1;
  Transaction observation = 2;
}

message DownloadResponse {
  repeated UtxoEntry utxo_entries = 1;
  repeated TransactionEntry transactions = 2;
  repeated ObservationEntry observations = 3;
  repeated ObservationEdge observation_edges = 4;
  bool complete_response = 5;
  repeated Hash hashes = 6;
}

message GetPeersInfoRequest {

}

message PeerNodeInfo {
  Transaction latest_peer_transaction = 1;
  Transaction latest_node_transaction = 2;
  DynamicNodeMetadata dynamic_node_metadata = 3;
}

message PeerIdInfo {
  Transaction latest_peer_transaction = 1;
  repeated PeerNodeInfo peer_node_info = 2;
}

message GetPeersInfoResponse {
  PeerNodeInfo self_info = 1;
  repeated PeerNodeInfo peer_info = 2;
}

// Not used
message MultipartyBroadcast {
  RoomId room_id = 1;
  string message = 2;
}

message MultipartyIssueUniqueIndex {
  RoomId room_id = 1;
}

message MultipartyIssueUniqueIndexResponse {
  int64 unique_index = 1;
}

message MultipartySubscribe {
  RoomId room_id = 1;
  optional int64 last_event_id = 2;
  bool shutdown = 3;
}

message MultipartySubscribeEvent {
  RoomId room_id = 1;
  string id = 2;
  string message = 3;
}

message UtxoConflictResolveRequest {
  repeated UtxoId utxo_ids = 1;
  Hash transaction_hash = 2;
}

message UtxoConflictResolveResponse {
  repeated TransactionInfo transactions = 1;
}

message QueryObservationProofRequest{
  Hash hash = 1;
}

message QueryObservationProofResponse {
  repeated ObservationProof observation_proof = 1;
}

message MultipartyAuthenticationRequest {
  optional string message = 1;
  RoomId room_id = 2;
}

message HealthRequest {

}

message GetNodeTransactionRequest {

}

message GetContractStateMarkerRequest {
  // TODO: should this be its own id class?
  Address address = 1;
  StateSelector selector = 2;
}

message RecentDiscoveryTransactionsResponse {
  repeated Hash transaction_hashes = 1;
}

message RecentDiscoveryTransactionsRequest {
  optional int64 limit = 1;
  optional int64 min_time = 2;
}

message TransactionAndObservations {
  Transaction transaction = 1;
  repeated Observation observation = 2;
}

message RecentTransactionAndObservationRequest {
  optional int64 limit = 1;
  optional int64 offset = 3;
}

message GenesisRequest {

}

message GetPartiesInfoRequest {

}

message BatchTransactionResolveRequest {
  repeated Hash hashes = 1;
  optional bool is_observation = 2;
}

message BatchTransactionResolveResponse {
  repeated TransactionEntry transactions = 1;
}

message GetActivePartyKeyRequest {

}

message GetSeedsRequest {

}

message KeepAliveRequest {

}

enum TransportBackend {
  REST = 0;
  UDP = 1;
}

message PortOpenRequest {
  string ip = 1;
  int64 port = 2;
  TransportBackend transport = 3;
}

message Request {
  optional GossipTransactionRequest gossip_transaction_request = 1;
  optional GossipObservationRequest gossip_observation_request = 2;
  optional ResolveHashRequest resolve_hash_request = 3;
  optional DownloadRequest download_request = 4;
  AboutNodeRequest about_node_request = 5;
  Proof proof = 7;
  NodeMetadata node_metadata = 8;
  GetPeersInfoRequest get_peers_info_request = 9;
  InitiateMultipartyKeygenRequest initiate_keygen = 10;
  InitiateMultipartySigningRequest initiate_signing = 17;
  SubmitTransactionRequest submit_transaction_request = 11;
  UtxoConflictResolveRequest utxo_conflict_resolve_request = 12;
  QueryObservationProofRequest query_observation_proof_request = 13;
  HashSearchRequest hash_search_request = 14;
  optional string trace_id = 15;
  optional bool trace = 16;
  MultipartyAuthenticationRequest multiparty_authentication_request = 18;
  HealthRequest health_request = 19;
  GetNodeTransactionRequest get_node_transaction_request = 20;
  GetContractStateMarkerRequest get_contract_state_marker_request = 21;
  Address resolve_code_request = 22;
  AbridgedNodeMetadata abridged_node_metadata = 23;
  repeated ObservationProof gossip_observation_proof = 24;
  UtxoId utxo_valid_request = 25;
  RecentDiscoveryTransactionsRequest recent_transactions_request = 26;
  Hash lookup_transaction_request = 27;
  RecentTransactionAndObservationRequest recent_transaction_and_observation_request = 28;
  GenesisRequest genesis_request = 29;
  FaucetRequest faucet_request = 30;
  GetPartiesInfoRequest get_parties_info_request = 31;
  optional string origin = 32;
  BatchTransactionResolveRequest batch_transaction_resolve_request = 33;
  PublicKey get_address_info_public_key_request = 34;
  GetActivePartyKeyRequest get_active_party_key_request = 35;
  GetSeedsRequest get_seeds_request = 36;
  PublicKey get_public_key_balance_request = 37;
  KeepAliveRequest keep_alive_request = 38;
  Response response = 39;
  PortOpenRequest port_open_request = 40;
  GuiInitRequest gui_init_request = 41;
  MultipartyCheckReadyRequest multiparty_check_ready_request = 42;
  GetSolanaAddress get_solana_address = 43;
  MoneroMultisigFormationRequest monero_multisig_formation_request = 44;
}

message MoneroMultisigFormationRequest {
  repeated string peer_strings = 1;
}

message GetSolanaAddress {}

message MultipartyCheckReadyRequest {
  PublicKey party_key = 1;
}

message GuiInitRequest {
  repeated PublicKey public_keys = 1;
}

message HealthResponse {

}

message ResolveCodeResponse {
  UtxoEntry utxo_entry = 1;
  TransactionInfo transaction = 2;
  ContractStateMarker contract_state_marker = 3;
}

message UtxoValidResponse {
  optional bool valid = 1;
  Transaction child_transaction = 2;
  optional int64 child_transaction_input = 3;
}

message PortOpenResponse {
  bool open = 1;
}

message Response {
  ResponseMetadata response_metadata = 1;
  // Pull in other response classes if needed.
  optional ResolveHashResponse resolve_hash_response = 2;
  optional DownloadResponse download_response = 3;
  AboutNodeResponse about_node_response = 4;
  GetPeersInfoResponse get_peers_info_response = 5;
  NodeMetadata node_metadata = 6;
  Proof proof = 7;

  InitiateMultipartyKeygenResponse initiate_keygen_response = 8;
  InitiateMultipartySigningResponse initiate_signing_response = 13;

  SubmitTransactionResponse submit_transaction_response = 9;
  UtxoConflictResolveResponse utxo_conflict_resolve_response = 10;
  QueryObservationProofResponse query_observation_proof_response = 11;
  HashSearchResponse hash_search_response = 12;
  HealthResponse health_response = 14;
  ContractStateMarker get_contract_state_marker_response = 15;
  ResolveCodeResponse resolve_code_response = 16;
  UtxoValidResponse utxo_valid_response = 17;
  RecentDiscoveryTransactionsResponse recent_discovery_transactions_response = 18;
  Transaction lookup_transaction_response = 19;
  repeated TransactionAndObservations recent_transaction_and_observation_response = 20;
  Transaction genesis_response = 21;
  FaucetResponse faucet_response = 22;
  GetPartiesInfoResponse get_parties_info_response = 23;
  BatchTransactionResolveResponse batch_transaction_resolve_response = 24;
  AddressInfo get_address_info_public_key_response = 25;
  PublicKey get_active_party_key_response = 26;
  repeated Seed get_seeds_response = 27;
  CurrencyAmount get_public_key_balance_response = 28;
  KeepAliveResponse keep_alive_response = 29;
  PortOpenResponse port_open_response = 30;
  optional bool multiparty_check_ready_response = 31;
  Address get_solana_address_response = 32;
}

message KeepAliveResponse {
  string ip = 1;
  int64 port = 2;
}

message PartyMember {
  PublicKey public_key = 1;
  Weighting weight = 2;
}

message PartyInfoAbridged {
  PartyId party_id = 1;
  Weighting threshold = 2;
  repeated PartyMember members = 3;
  repeated CurrencyAmount balances = 4;
}

message GetPartiesInfoResponse {
  repeated PartyInfoAbridged party_info = 1;
}

message QueryTransactionRequest {
  Hash transaction_id = 1;
}


message MerkleProof {
  Hash root = 1;
  Hash leaf = 2;
  repeated Hash nodes = 3;
}

message ObservationProof {
  // Transaction hash associated with the observation
  Hash observation_hash = 1;
  // Proof of this particular observation within the merkle root of the observation
  MerkleProof merkle_proof = 2;
  ObservationMetadata metadata = 3;
  Proof proof = 4;
}

message QueryTransactionResponse {
  repeated ObservationProof observation_proofs = 1;
}

message SubmitTransactionRequest {
  Transaction transaction = 1;
  bool sync_query_response = 2;
}

// TODO: This should just return the entire transaction with it's hash also calculated
// Also include the signing hash in the response, modify transaction schema for that
message SubmitTransactionResponse {
  Hash transaction_hash = 1;
  QueryTransactionResponse query_transaction_response = 2;
  Transaction transaction = 3;
}

message AboutNodeRequest {
  bool verbose = 1;
}

message AboutNodeResponse {
  Transaction latest_metadata = 2;
  Transaction latest_node_metadata = 3;
  int64 num_known_peers = 4;
  int64 num_active_peers = 5;
  repeated Transaction recent_transactions = 6;
  int64 pending_transactions = 7;
  int64 total_accepted_transactions = 8;
  int64 observation_height = 9;
  PeerNodeInfo peer_node_info = 10;
}

enum AddressType {
  // Original default address type, SHA3-224 checksum of the public key, along with a checksum suffix
  // 28 bytes + 4 byte checksum = 32 bytes for the direct information, proto ser form is used to add version info
  // with another 4 bytes
  Sha3_224_Checksum_Public = 0;
  // Direct Bitcoin address string embedded as UTF bytes
  Bitcoin_External_String = 2;
  // This is intended to be used with RSV signature verification.
  ETHEREUM_COMPAT_ADDRESS = 3;
  // Not used anywhere, but could be used for direct public key addresses
  PUBLIC_KEY_DIRECT_ADDRESS = 4;
  // Unclear if needed except for debugging
  UNKNOWN_ADDRESS_TYPE = 5;
  SCRIPT_HASH = 6;
  // Direct Ethereum string hash reference with embedded string upper/lower checksum.
  Ethereum_External_String = 7;
  Monero_External_String = 8;
  Solana_External_String = 9;
}

message Address {
  BytesData address = 1;
  AddressType address_type = 2;
  SupportedCurrency currency = 3;
}

message QueryAddressesRequest {
  repeated Address addresses = 1;
}

message QueryAddressesResponse {
  repeated UtxoEntry utxo_entries = 1;
}

message FaucetRequest {
  Address address = 1;
  optional string token = 2;
}
// Should this just be transactionInfo?
message FaucetResponse {
  SubmitTransactionResponse submit_transaction_response = 1;
}

message RecentTransactionsRequest {}
message RecentTransactionsResponse {
  repeated Transaction transactions = 1;
}

message HashSearchRequest {
  string search_string = 1;
  // TODO: Optional data types etc.
}

message UsedOutputs {
  UtxoId utxo_id = 1;
  repeated ObservationProof proof = 2;
}

message TransactionInfo {
  Transaction transaction = 1;
  repeated ObservationProof observation_proofs = 2;
  // Which output indexes are still considered valid.
  repeated int32 valid_utxo_index = 3;
  // In order to calculate this quantity, we need another index to determine if something has been used.
  repeated UsedOutputs used_outputs = 4;
  bool accepted = 5;
  ErrorInfo rejection_reason = 6;
  // Move this outside to the class / request that requires it for resolving.
  optional bool queried_output_index_valid = 7;
  TransactionState state = 8;
}

message AddressInfo {
  Address address = 1;
  repeated UtxoEntry utxo_entries = 2;
  int64 balance = 3;
  repeated Transaction recent_transactions = 4;
  repeated CurrencyAmount balances = 5;
}

message HashSearchResponse {
  TransactionInfo transaction_info = 1;
  AddressInfo address_info = 2;
  Transaction observation = 3;
  PeerNodeInfo peer_node_info = 4;
  PeerIdInfo peer_id_info = 5;
}

message PublicRequest {
  optional SubmitTransactionRequest submit_transaction_request = 1;
  optional QueryTransactionRequest query_transaction_request = 2;
  optional AboutNodeRequest about_node_request = 3;
  optional QueryAddressesRequest query_addresses_request = 4;
  // Debug only
  FaucetRequest faucet_request = 5;
  RecentTransactionsRequest recent_transactions_request = 6;
  HashSearchRequest hash_search_request = 7;
}


message PublicResponse {
  optional ResponseMetadata response_metadata = 1;
  optional SubmitTransactionResponse submit_transaction_response = 2;
  optional QueryTransactionResponse query_transaction_response = 3;
  optional AboutNodeResponse about_node_response = 4;
  optional QueryAddressesResponse query_addresses_response = 5;
  FaucetResponse faucet_response = 6;
  RecentTransactionsResponse recent_transactions_response = 7;
  HashSearchResponse hash_search_response = 8;
}

message ErrorDetails {
  string detail_name = 1;
  string detail = 2;
}

message ErrorInfo {
  ErrorCode code = 1;
  string description = 2;
  string description_extended = 3;
  string message = 4;
  repeated ErrorDetails details = 5;
  bool retriable = 6;
  string stacktrace = 7;
  string lib_message = 8;
  bool abort = 9;
  bool skip_logging = 10;
  optional string internal_log_level = 11;
}

message TaskLocalDetails {
  string key = 1;
  string value = 2;
}

message ResponseMetadata {
  bool success = 1;
  ErrorInfo error_info = 2;
  repeated TaskLocalDetails task_local_details = 3;
  optional string request_id = 4;
  optional string trace_id = 5;
}

message RoomId {
  optional string uuid = 1;
}

message MultipartyIdentifier {
  repeated PublicKey party_keys = 1;
  Weighting threshold = 2;
  RoomId room_id = 3;
}

message ControlMultipartyKeygenRequest {
  optional MultipartyIdentifier multiparty_identifier = 1;
  bool return_local_share = 2;
}

message ControlMultipartyKeygenResponse {
  optional string local_share = 1;
  MultipartyIdentifier multiparty_identifier = 2;
}

message ControlMultipartySigningRequest {
  InitiateMultipartySigningRequest signing_request = 1;
}

message ControlMultipartySigningResponse {
  Proof proof = 1;
  MultipartyIdentifier identifier = 2;
}

enum PartyPurpose {
  StandardPurpose = 0;
  DebugPurpose = 1;
}

message InitiateMultipartyKeygenRequest {
  MultipartyIdentifier identifier = 1;
  int64 time = 2;
  repeated PublicKey prior_keys = 3;
  PartyPurpose purpose = 4;
}

message InitiateMultipartyKeygenResponse {
  InitiateMultipartyKeygenRequest initial_request = 2;
}

message InitiateMultipartySigningResponse{
  Proof proof = 1;
  InitiateMultipartySigningRequest initial_request = 2;
}

message PartySigningValidation {
  optional string json_payload = 1;
  SupportedCurrency currency = 2;
  Transaction transaction = 3;
}

message InitiateMultipartySigningRequest {
  MultipartyIdentifier identifier = 1;
  RoomId signing_room_id = 2;
  repeated PublicKey signing_party_keys = 3;
  BytesData data_to_sign = 4;
  PartySigningValidation party_signing_validation = 5;
  optional bool skip_party_key_lookup = 6;
}



message ControlRequest {
//  AddPeerFullRequest add_peer_full_request = 1;
  ControlMultipartyKeygenRequest control_multiparty_keygen_request = 2;
  ControlMultipartySigningRequest control_multiparty_signing_request = 3;
}

message UpdatePeerTrustRequest {}


message ControlResponse {
  ResponseMetadata response_metadata = 1;
  ControlMultipartyKeygenResponse control_multiparty_keygen_response = 2;
  ControlMultipartySigningResponse control_multiparty_signing_response = 3;
}

enum ErrorCode {
  /// Signature failed verification
  IncorrectSignature = 0;
  MissingInputs = 1;
  MissingOutputs = 2;
  InvalidAddressInputIndex = 3;
  InvalidHashLength = 4;
  TransactionAlreadyProcessing = 5;
  UnknownUTXO = 6;
  BalanceMismatch = 7;
  InsufficientBalance = 8;
  InsufficientFee = 9;
  MissingProof = 10;
  TransactionRejectedDoubleSpend = 11;
  InternalDatabaseError = 12;
  AddressPublicKeyProofMismatch = 13;
  UnknownError = 14;
  DatabaseFailure = 15;
  MissingField = 16;
  ProtoDecoderFailure = 17;
  InvalidNetworkEnvironment = 18;
  DataStoreInternalCorruption = 19;
  HexDecodeFailure = 20;
  AddressDecodeFailure = 21;
  UnsupportedCurrency = 22;
  AddressNotFound = 23;
  UnknownTransaction = 24;
  UnknownBlock = 25;
  InternalChannelSendError = 26;
  InternalChannelReceiveError = 27;
  ParseFailure = 28;
  DeserializationFailure = 29;
  SerializationFailure = 30;
}

enum NodeType {
  Ephemeral = 0;
  Static = 1;
}

enum NodeState {
  Ready = 0;
  Offline = 2;
  Initializing = 3;
  Downloading = 4;
  Synchronizing = 5;
  ShuttingDown = 6;
}

message UdpMessage {
  BytesData bytes = 1;
  int64 part = 2;
  int64 parts = 3;
  string uuid = 4;
  int64 timestamp = 5;
}

message Seed {
  string external_address = 1;
  repeated NetworkEnvironment environments = 2;
  optional uint32 port_offset = 3;
  repeated TrustData trust = 4;
  PeerId peer_id = 5;
  optional PublicKey public_key = 6;
}


message DebugVersionChange {
  optional string field1 = 1;
}

message DebugVersionChange2 {
  optional string field1 = 1;
  optional string field2 = 2;
}

enum TransactionState {
  Rejected = 0;
  Mempool = 1;
  Validated = 2;
  ObservedPending = 3;
  ObservedAccepted = 4;
  Finalized = 5;
  Unknown = 6;
  ObservedReverted = 7;
}

enum SupportedCurrency {
  Redgold = 0;
  Bitcoin = 1;
  Ethereum = 2;
  Usd = 3;
  UsdcEth = 4;
  UsdtEth = 5;
  Solana = 6;
  Monero = 7;
  Cardano = 8;
  WrappedRedgoldEthereum = 9;
  WrappedRedgoldSolana = 10;
}
//
//enum CurrencyType {
//  Fiat = 0;
//  Crypto = 1;
//  Stablecoin = 2;
//  Token = 3;
//}
//
//enum CurrencyContractType {
//
//}

message CurrencyDescriptor {
  SupportedCurrency network_currency = 1;
  Address contract = 2;
}

message CurrencyId {
  SupportedCurrency supported_currency = 1;
  CurrencyDescriptor descriptor = 2;
}


message ExecutionInput {
  Transaction tx = 1;
  BytesData input = 2;
  BytesData state = 3;
}

message ExecutionResult {
  bool valid = 1;
  ResponseMetadata result_metadata = 2;
  StandardData data = 3;
}

message StateSelector {
  // TODO: query selector
}

message ContractStateMarker {
  Address address = 1;
  BytesData state = 2;
  StateSelector selector = 3;
  Hash transaction_marker = 4;
  int64 index_counter = 5;
  int64 time = 6;
}

// Any value which can cause a conflict or collision among nodes due to disagreements in ordering.
message ContentionKey {
  // Classical conflict condition associated with double spends, two transactions which share a common parent
  // causing a conflict or contention.
  UtxoId utxo_id = 1;
  // Conflict conditions associated with deployed single-address contracts
  Address address = 2;
  // Combined with above address -- imposes a conflict ordering condition among a state subset denoted by a key index
  StateSelector selector = 3;
  // Duplicate transaction hash conflict condition -- associated with duplicate processing of same data.
  // Primarily used internally for tracking internal contentions.
  Hash transaction_hash = 4;
}


message TestContractUpdate {
  string key = 1;
  string value = 2;
}

message TestContractUpdate2 {
  string value = 2;
}

message TestContractInternalState {
  repeated TestContractUpdate test_map = 1;
  optional string latest_value = 2;
}

message TestContractRequest {
  TestContractUpdate test_contract_update = 1;
  TestContractUpdate2 test_contract_update2 = 2;
}

message DebugSerChange {
  string field1 = 1;
  optional string field2 = 2;
}

message DebugSerChange2 {
  string field1 = 1;
}


// Imports not working properly due to issue with prost
//import "execution.proto";

// This doesn't work due to prost import issue, important to fix later
//
//message TestMessageOuter {
//  execution.TestMessage inner = 1;
//}

enum LocalShareType {
  MultipartyEcdsaCurvKzen = 0;
}

message LocalKeyShare {
  optional string local_share = 1;
  LocalShareType share_type = 2;
  optional int32 version = 3;
}


message PartyData {
  // Used for db storage for internal types.
  optional string json_party_internal_data = 1;
}

enum PriceSource {
  OkxMinute = 0;
}

message PriceTime {
  Weighting price = 1;
  int64 time = 2;
  SupportedCurrency currency = 3;
  PriceSource source = 4;
  SupportedCurrency denomination = 5;
}