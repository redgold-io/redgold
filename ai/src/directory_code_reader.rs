use std::fs;
use std::fs::File;
use std::io::{BufRead, BufReader};
use std::path::{Path, PathBuf};

use jemini::{GeminiError, GeminiResponse, JeminiClient};
use tiktoken_rs::num_tokens_from_messages;

fn directory_exclusions() -> Vec<String> {
    vec![
        ".git",
        "target",
        "node_modules",
        ".idea",
        "experiments",
    ].iter().map(|s| s.to_string()).collect()
}

fn endings_exclusions() -> Vec<String> {
    vec![
        "png",
        "jpeg",
        "jpg",
        "svg",
        "ico",
        "webp",
        "bin"
    ].iter().map(|s| s.to_string()).collect()
}

fn file_exclusions() -> Vec<String> {
    vec![
        ".DS_Store",
        ".wasm",
        // Banned for being too large and less useful
        "graph_data.csv",
        "node-exporter-full_rev31.json",
        "api.json",
        "full_moon.csv",
        "models.rs", // Rosetta autogenerated models, probably not really needed for a while
        "grafana.ini"
    ].iter().map(|s| s.to_string()).collect()
}


fn file_inclusions() -> Vec<String> {
    vec![
        ".env",
        ".gitignore",
        "Dockerfile",
        "NOTICE",
        "certificate_renewal"
    ].iter().map(|s| s.to_string()).collect()
}


fn endings_inclusions() -> Vec<String> {
    vec![
        "rs",
        "sh",
        "md",
        "toml",
        "yaml",
        "py",
        "js",
        "json",
        "production",
        "html",
        "env",
        "yml",
        "sol",
        "abi",
        "csv",
        "txt",
        "service",
        "vue",
        "proto",
        "sql",
        "Dockerfile",
        "conf",
        "ini",
        // "lock", // maybe?
        "ts"
    ].iter().map(|s| s.to_string()).collect()
}


#[derive(Clone)]
struct AccumFileData {
    good_files: Vec<PathBuf>,
    unknown_files: Vec<PathBuf>
}


fn process_file(
    file: &PathBuf, accum: &mut AccumFileData,
    file_exclusions: &Vec<String>,
    file_inclusions: &Vec<String>,
    endings_exclusions: &Vec<String>,
    endings_inclusions: &Vec<String>
) {
    let file_name = file.file_name().unwrap().to_str().unwrap();
    if file_exclusions.contains(&file_name.to_string()) {
        return;
    }
    if file_inclusions.contains(&file_name.to_string()) {
        accum.good_files.push(file.clone());
        return
    }
    if let Some(ext) = file.extension() {
        let ext_str = ext.to_str().unwrap().to_string();
        if endings_exclusions.contains(&ext_str) {
            return;
        }
        if endings_inclusions.contains(&ext_str) {
            accum.good_files.push(file.clone());
            return
        }
    }

    accum.unknown_files.push(file.clone());
}

struct ScanConfig {
    exclude_vue: bool,
    exclude_docs: bool
}

impl ScanConfig {
    fn new() -> ScanConfig {
        ScanConfig {
            exclude_vue: false,
            exclude_docs: false,
        }
    }

}

fn scan_tld(
    scan_config: Option<ScanConfig>
) -> AccumFileData {
    let current_dir = std::env::current_dir().expect("Failed to get current directory");
    let parent_dir = current_dir.parent().expect("Failed to get parent directory");

    let accum = &mut AccumFileData {
        good_files: Vec::new(),
        unknown_files: Vec::new()
    };

    let mut directory_exclusions = directory_exclusions();
    let mut file_exclusions = file_exclusions();
    let mut file_inclusions = file_inclusions();
    let mut endings_exclusions = endings_exclusions();
    let mut endings_inclusions = endings_inclusions();

    if let Some(config) = scan_config {
        if config.exclude_vue {
            directory_exclusions.push("vue-website".to_string());
            directory_exclusions.push("vue-explorer".to_string());
        }
        if config.exclude_docs {
            directory_exclusions.push("docs".to_string());
        }
    }

    scan_dir(parent_dir, accum,
             &directory_exclusions, &file_exclusions, &file_inclusions, &endings_exclusions, &endings_inclusions);
    accum.clone()
}

fn scan_dir(
    dir: &Path, accum: &mut AccumFileData,
    directory_exclusions: &Vec<String>,
    file_exclusions: &Vec<String>,
    file_inclusions: &Vec<String>,
    endings_exclusions: &Vec<String>,
    endings_inclusions: &Vec<String>
) {
    if directory_exclusions.contains(&dir.file_name().unwrap().to_str().unwrap().to_string()) {
        return;
    }
    for entry in fs::read_dir(dir).expect("Failed to read directory") {
        if let Ok(entry) = entry {
            let path = entry.path();
            if path.is_file() {
                process_file(&path, accum, file_exclusions, file_inclusions, endings_exclusions, endings_inclusions);
            } else if path.is_dir() {
                scan_dir(&path, accum, directory_exclusions, file_exclusions, file_inclusions, endings_exclusions, endings_inclusions);
            }
        }
    }
}


impl AccumFileData {
    fn new() -> AccumFileData {
        AccumFileData {
            good_files: Vec::new(),
            unknown_files: Vec::new()
        }
    }
    fn from_config(config: ScanConfig) -> AccumFileData {
        scan_tld(Some(config))
    }
    fn contents_all(&self) -> String {
        let mut all_content = String::new();
        for gf in &self.good_files {
            let contents = fs::read_to_string(&gf).expect("Failed to read file");
            let filepath = gf.to_str().unwrap().to_string();
            all_content = format!("{}\nTEXT BELOW FROM FILE PATH: {}\n{}", all_content, filepath, contents);
        }
        all_content
    }

    fn token_count_all(&self) -> i64 {
        let content = self.contents_all();
        count_tokens(&content)
    }

    fn contents_path(&self) -> Vec<(String, String)> {
        let mut vec = vec![];
        for gf in &self.good_files {
            let contents = fs::read_to_string(&gf).expect("Failed to read file");
            let filepath = gf.to_str().unwrap().to_string();
            vec.push((filepath, contents));
        }
        vec
    }

    fn line_counts(&self) -> Vec<(String, i64)> {
        let mut vec = vec![];
        for gf in &self.good_files {
            let filepath = gf.to_str().unwrap().to_string();
            let lc = count_lines(&*filepath).expect("lc");
            vec.push((filepath, lc as i64));
        }
        vec.sort_by(|a, b| b.1.cmp(&a.1));
        vec
    }

    fn token_counts(&self) -> Vec<(String, i64)> {
        let mut vec = vec![];
        for (path, contents) in self.contents_path() {
            let tc = count_tokens(&contents);
            vec.push((path, tc));
        }
        vec.sort_by(|a, b| b.1.cmp(&a.1));
        vec
    }

}

pub fn count_lines(file_path: &str) -> Result<usize, std::io::Error> {
    let file = File::open(file_path)?;
    let reader = BufReader::new(file);
    let line_count = reader.lines().count();
    Ok(line_count)
}

// #[ignore]
#[test]
fn test_scan_tld() {
    let config = ScanConfig::new();
    let ac = AccumFileData::from_config(config);
    println!("Token count: {}", ac.token_count_all());
    let lc = ac.line_counts();
    let tlc = lc.iter().map(|x| x.1).sum::<i64>();
    println!("Total line count: {}", tlc);
    println!("Line counts: {:?}", lc);
    println!("Token counts: {:?}", ac.token_counts());
}

#[tokio::test]
async fn gemini_test() -> Result<(), GeminiError> {
    let client = JeminiClient::new()?;
    let response: GeminiResponse = client.text_only("What is the meaning of life?").await?;

    dbg!(&response);
    println!("{}", response.most_recent().unwrap());

    Ok(())

}


pub fn count_tokens(content: &String) -> i64 {
    use tiktoken_rs::ChatCompletionRequestMessage;

    let messages = vec![
        ChatCompletionRequestMessage {
            content: Some(content.clone()),
            // role: "system".to_string(),
            role: "user".to_string(),
            name: None,
            function_call: None,
        },
    ];
    let num_tokens = num_tokens_from_messages(
        "gpt-4",
        &messages
    ).expect("Failed to count tokens");
    num_tokens as i64
}